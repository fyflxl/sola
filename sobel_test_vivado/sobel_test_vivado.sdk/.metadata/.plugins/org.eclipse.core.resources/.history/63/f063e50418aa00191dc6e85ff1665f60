/************************************  Header Section  *********************************************
 --
 -- NAME       : Wang Zhibin
 -- Data       : June, 2012
 -- E-mail	   : stepzhibin@gmail.com
 -- Address    : Department of Electrical Engineering, Jiangnan University

 -- Filename   : util.c
 -- Description: Simple Image Operation Function and Image Input and Output Interface
 --
*********************************** End Header Section  *********************************************/

/*Standard includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

/*Our includes*/
#include "util.h"

#define LENGTH 80

/**************************************************************************************************
 *								Get Next String From the FILE
 **************************************************************************************************/
void _getNextString(FILE *fp, char *line)
{
	int i;

	line[0] = '\0';

	while(line[0] == '\0')
	{
		fscanf(fp, "%s", line);
		i = -1;
		do{
			i++;
			if(line[i] == '#')
			{
				line[i] = '\0';
				while(fgetc(fp) != '\n');
			}
		}while(line[i] != '\0');
	}
}


/**************************************************************************************************
 *								pgm Read Header
***************************************************************************************************/
void pgmReadHeader( FILE *fp, int *magic, int *ncols, int *nrows, int *maxval)
{
  	char line[LENGTH];

 	 /* Read magic number */
  	_getNextString(fp, line);
  	if (line[0] != 'P')
	{
    		printf("(pgmReadHeader) Magic number does not begin with 'P', ""but with a '%c'\n", line[0]);
	}
  	sscanf(line, "P%d", magic);
	if (*magic != 5)
  	{
    		printf("(pgmReadHeader) Magic number is not 'P5', but 'P%d' \n", *magic);
	}

  	/* Read size, skipping comments */
  	_getNextString(fp, line);
  	*ncols = atoi(line);
  	_getNextString(fp, line);
  	*nrows = atoi(line);
  	if (*ncols < 0 || *nrows < 0 || *ncols > 10000 || *nrows > 10000)
	{
    		printf("(pnmReadHeader) The dimensions %d x %d are unacceptable\n",*ncols, *nrows);
	}
  	/* Read maxval, skipping comments */
  	_getNextString(fp, line);
  	*maxval = atoi(line);
  	fread(line, 1, 1, fp); /* Read newline which follows maxval */

  	if (*maxval != 255)
	{
    		printf("(pnmReadHeader) Max val is not 255, but %d \n", *maxval);
	}
}



/**************************************************************************************************
 *										pgm	Read Header	File
 **************************************************************************************************/
void pgmReadHeaderFile(char *fname, int *magic, int *ncols, int *nrows, int *maxval)
{
	FILE *fp;

  	/* Open file */
  	if ( (fp = fopen(fname, "rb")) == NULL)
	{
    		printf("(pgmReadHeaderFile) Can't open file named '%s' for reading\n", fname);
	}
  	/* Read header */
  	pgmReadHeader(fp, magic, ncols, nrows, maxval);

  	/* Close file */
  	fclose(fp);
}




/**************************************************************************************************
 * 						pgm	Read
 **************************************************************************************************/
unsigned char *pgmRead(FILE *fp,int *ncols, int *nrows)
{
	unsigned char *ptr;
  	int magic, maxval;

	/* Read header */
  	pgmReadHeader(fp, &magic, ncols, nrows, &maxval);

  	/* Allocate memory, if necessary, and set pointer */

	ptr = (unsigned char *)malloc(*nrows * *ncols * sizeof(unsigned char));
	if(!ptr)
	{
		perror("Cannot allocate memory for gray!\n");
		exit(EXIT_SUCCESS);
	}
	memset(ptr, 0, *nrows * *ncols );

	fread(ptr,1,*nrows * *ncols, fp);
	return ptr;
}


/**************************************************************************************************
 *									pgm Read File
 **************************************************************************************************/
unsigned char *pgmReadFile(char *fname, int *ncols, int *nrows)
{
	unsigned char *ptr;
  	FILE *fp;

  	/* Open file */
  	if ( (fp = fopen(fname, "rb")) == NULL)
	{
    		printf("(pgmReadFile) Can't open file named '%s' for reading\n", fname);
	}
  	/* Read file */
  	ptr = pgmRead(fp, ncols, nrows);

  	/* Close file */
  	fclose(fp);

  	return ptr;
}


/**************************************************************************************************
 * 									pgm Write
 **************************************************************************************************/
void pgmWrite(FILE *fp, unsigned char *img, int ncols, int nrows)
{
	//int i;

  	/* Write header */
  	fprintf(fp, "P5\n");
  	fprintf(fp, "%d %d\n", ncols, nrows);
  	fprintf(fp, "255\n");

  	/* Write binary data */
	fwrite(img, 1, ncols * nrows, fp);
}


/****************************************************************************************************
 * 			pgmWriteFile
 ****************************************************************************************************/
void pgmWriteFile(char *fname, unsigned char *img, int ncols, int nrows)
{
	FILE *fp;

  	/* Open file */
  	if ( (fp = fopen(fname, "wb")) == NULL)
	{
    		printf("(pgmWriteFile) Can't open file named '%s' for writing\n", fname);
	}
  	/* Write to file */
  	pgmWrite(fp, img, ncols, nrows);

  	/* Close file */
  	fclose(fp);
}

/**************************************************************************************************
 * 					Convert Binary Image to Float Image
 **************************************************************************************************/
void BinToFloatImage(unsigned char *img, int ncols, int nrows, float *floatimg)
{
	float *ptrout = floatimg;

	unsigned char *ptrend = img + ncols*nrows;

	while(img < ptrend)
	{
		*ptrout++ = (float) *img++;
	}
}


/**************************************************************************************************
 * 		Allocate Memory for Float Image
 * ************************************************************************************************/
float *CreateFloatImage(int ncols, int nrows)
{
	float *floatimg;
	floatimg = (float *)malloc(ncols * nrows * sizeof(float));
	if(!floatimg)
	{
		perror("Allocate Memory for Float Image Failed!\n");
		exit(EXIT_SUCCESS);
	}
	memset(floatimg, ncols * nrows * sizeof(float), 0);

	return floatimg;
}

/**************************************************************************************************
 *               Free Memory for Float Image
 **************************************************************************************************/
void FreeFloatImage(float *floatimg)
{
	free(floatimg);
}

/**************************************************************************************************
 *					Create Pyramid Image
 **************************************************************************************************/
Pyramid CreatePyramidImage(int ncols, int nrows, int nlevels, float ratio)
{
	int i, temp, nbytes;
	Pyramid pyramid;
	int ncol, nrow;
	nbytes = sizeof(PyramidRec) + nlevels * sizeof(float **) + nlevels * sizeof(int) + nlevels * sizeof(int);

	/*Allocate memeory for structure and set parameters*/
	pyramid = (Pyramid)malloc(nbytes);
	if(!pyramid)
	{
		perror("Can not allocate memory for Pyramid Image!\n");
		exit(EXIT_SUCCESS);
	}
	memset(pyramid, nbytes, 0);

	/*Set parameters*/
	pyramid->ratio = ratio;
	pyramid->nLevels = nlevels;
	pyramid->img = (float **)(pyramid + 1);
	pyramid->ncols = (int *)(pyramid->img + nlevels);
	pyramid->nrows = (int *)(pyramid->ncols + nlevels);

	/* Allocate memory for each level of pyramid and assign pointers */
	for (i = 0 ; i < nlevels ; i++)
	{

		ncol = (int)floor(ncols * (pow(ratio, (float)(i))) );
		nrow = (int)floor(nrows * (pow(ratio, (float)(i))) );

		pyramid->img[i] = CreateFloatImage(ncol, nrow);
		pyramid->ncols[i] = ncol;
		pyramid->nrows[i] = nrow;

		// nlevels too large, correct it
		if(ncols < 1 || nrows < 1)
		{
			if(ncols < 1)
			{
				temp = (int)floor(log(ncols)/log(2));
				ncols = (int)floor(ncols * (pow(2.0,(float)(temp))) );
				nrows = (int)floor(nrows * (pow(2.0,(float)(temp))) );
			}

			if(nrows < 1)
			{
				temp = (int)floor(log(nrows)/log(2));
				ncols = (int)floor(ncols * (pow(2.0,(float)(temp))) );
				nrows = (int)floor(nrows * (pow(2.0,(float)(temp))) );
			}

			// Correct max_level as well
			printf("Warning: start_level too large!\n");

		}
	}
	return pyramid;
}

/**************************************************************************************************
 *					Free Pyramid Image
 **************************************************************************************************/
void FreePyramidImage(Pyramid pyramid)
{
	int i;

	/*Free images*/
	for(i = 0; i < pyramid->nLevels; i++)
	{
		free(pyramid->img[i]);
	}

	free(pyramid);
}

/**************************************************************************************************
 *					Init Pyramid Image
 **************************************************************************************************/
void InitPyramidImage(Pyramid pyramid)
{
	int i, j;
	for(i = 0; i < pyramid->nLevels; i++)
	{
		for(j = 0; j < (pyramid->ncols[i])*(pyramid->nrows[i]); j ++)
		{
			pyramid->img[i][j] = 0;
		}
	}
}

/**************************************************************************************************
 **              Show Float Image in file
 **************************************************************************************************/
void ShowFloatImage(FILE *fp, float *floatimg, int ncols, int nrows)
{
	int i,j;
	int offset;

	for(j = 0 ; j < nrows; j++)
	{
		for(i = 0; i < ncols; i++)
		{
			offset = j * ncols + i;
			fprintf(fp, "%4.8f \n", *(floatimg + offset));
		}
		//fprintf(fp, "\n");
	}
}

void ShowFloatImageFile(char *fname, float *floatimg, int ncols, int nrows)
{
	FILE *fp;

	if((fp = fopen(fname, "wb")) == NULL)
	{
		printf("Can not Create file named %s \n", fname);
		exit(EXIT_SUCCESS);
	}

	ShowFloatImage(fp, floatimg, ncols, nrows);
}

/**************************************************************************************************
 **              Show Flow Image in file
 **************************************************************************************************/
void ShowFlowImage(FILE *fp, float *floatimg, int ncols, int nrows)
{
	int i,j;
	int offset;

	for(j = 0 ; j < nrows; j++)
	{
		for(i = 0; i < ncols; i++)
		{
			offset = j * ncols + i;
			fprintf(fp, "%4.8f\n", *(floatimg + offset));
		}
		//fprintf(fp, "\n");
	}
}

void ShowFlowImageFile(char *fname, float *floatimg, int ncols, int nrows)
{
	FILE *fp;

	if((fp = fopen(fname, "wb")) == NULL)
	{
		printf("Can not Create file named %s \n", fname);
		exit(EXIT_SUCCESS);
	}

	ShowFlowImage(fp, floatimg, ncols, nrows);
}


/**************************************************************************************************
 **              Show Int Deriv Image in file
 **************************************************************************************************/
void ShowIntDerivImage(FILE *fp, float *floatimg, int ncols, int nrows)
{
	int i,j;
	int offset;
	int temp;

	for(j = 0 ; j < nrows; j++)
	{
		for(i = 0; i < ncols; i++)
		{
			offset = j * ncols + i;
			temp =  (int)((*(floatimg + offset))* DERIV_PRECISION);
			fprintf(fp, "%d\n", temp);
		}
		//fprintf(fp, "\n");
	}
}


void ShowIntDerivImageFile(char *fname, float *floatimg, int ncols, int nrows)
{
	FILE *fp;

	if((fp = fopen(fname, "wb")) == NULL)
	{
		printf("Can not Create file named %s \n", fname);
		exit(EXIT_SUCCESS);
	}

	ShowIntDerivImage(fp, floatimg, ncols, nrows);
}


/**************************************************************************************************
 **              Show Int Flow Image in file
 **************************************************************************************************/
void ShowIntFlowImage(FILE *fp, float *floatimg, int ncols, int nrows)
{
	int i,j;
	int offset;
	int temp;

	for(j = 0 ; j < nrows; j++)
	{
		for(i = 0; i < ncols; i++)
		{
			offset = j * ncols + i;
			temp =  (int)((*(floatimg + offset))* FLOW_PRECISION);
			fprintf(fp, "%d\n", temp);
		}
		//fprintf(fp, "\n");
	}
}


void ShowIntFlowImageFile(char *fname, float *floatimg, int ncols, int nrows)
{
	FILE *fp;

	if((fp = fopen(fname, "wb")) == NULL)
	{
		printf("Can not Create file named %s \n", fname);
		exit(EXIT_SUCCESS);
	}

	ShowIntFlowImage(fp, floatimg, ncols, nrows);
}

/**************************************************************************************************
 *   Convert Float Image to Binary Image
 **************************************************************************************************/
void WriteFloatImageToBin(float *img, int ncols, int nrows,char *filename)
{
	int npixs = ncols * nrows;
	float mmax = -999999.9f, mmin = 999999.9f;
	float fact;
	float *ptr;
	unsigned char *byteimg, *ptrout;
	int i;

	/* Calculate minimum and maximum values of float image */
	ptr = img;
	for (i = 0 ; i < npixs ; i++)
	{
		mmax = MAX(mmax, *ptr);
		mmin = MIN(mmin, *ptr);
		ptr++;
	}

	/* Allocate memory to hold converted image */
	byteimg = (unsigned char *) malloc(npixs * sizeof(char));

	/* Convert image from float to unsigned char */
	fact = 255.0f / (mmax-mmin);
	ptr = img;
	ptrout = byteimg;
	for (i = 0 ; i < npixs ; i++)
	{
		*ptrout++ = (unsigned char) ((*ptr++ - mmin) * fact);
	}

	/* Write unsigned char image to PGM*/
	pgmWriteFile(filename, byteimg, ncols, nrows);

	/* Free memory */
	free(byteimg);
}
/**************************************************************************************************
 *   Convert Float Image to Binary Image For Pyramid Image
 **************************************************************************************************/
void WritePyramidImageToBin(float *img, int ncols, int nrows,int dim, char *filename)
{

	float fact;
	float *ptr;
	unsigned char *byteimg, *ptrout;
	int i, j;
	int count = 0;
	float mmax = -999999.9f;
	float mmin = 999999.9f;

	/* Calculate minimum and maximum values of float image */
	ptr = img;
	for (i = 0 ; i < nrows ; i += dim)
	{
		for(j = 0; j < ncols; j += dim)
		{
			mmax = MAX(mmax, *ptr);
			mmin = MIN(mmin, *ptr);
			ptr++;
			count++;
		}
	}

	/* Allocate memory to hold converted image */
	byteimg = (unsigned char *) malloc(count * sizeof(char));

	/* Convert image from float to unsigned char */
	fact = 255.0f / (mmax-mmin);
	ptr = img;
	ptrout = byteimg;
	for (i = 0 ; i < count ; i++)
	{
		*ptrout++ = (unsigned char) ((*ptr++ - mmin) * fact);
	}

	/* Write unsigned char image to PGM*/
	pgmWriteFile(filename, byteimg, (int)(ncols/dim), (int)(nrows/dim));

	/* Free memory */
	free(byteimg);
}

/**************************************************************************************************
 *				Init Float Image
 **************************************************************************************************/
void InitFloatImage(float *img, int ncols, int nrows)
{
	int i;
	for(i = 0; i < ncols*nrows; i++)
	{
		img[i] = 0.0;
	}
}

/*********************************************************************************************
 *				Copy Float Image
 ********************************************************************************************/
void CopyFloatImage(float *img, int ncols, int nrows, float *cpimg)
{
	int i;
	for(i = 0; i < ncols * nrows; i++)
	{
		cpimg[i] = img[i];
	}
}


/**************************************************************************************************
 *				Add Float Flow
 **************************************************************************************************/
void AddFloatFlow(float *u, float *v, float *du, float *dv, int ncols, int nrows, float *tu, float *tv)
{
	int i;
	for(i = 0; i < ncols*nrows; i++)
	{
		tu[i] = u[i] + du[i];
		tv[i] = v[i] + dv[i];
	}
}


/**************************************************************************************************
 *						Multiple C =  A * B
 **************************************************************************************************/
void MulFloatImage(float *img1, float *img2, int ncols, int nrows, float *img)
{
	int i;

	for(i = 0; i < ncols*nrows; i++)
	{
		img[i] = (float)(img1[i]*img2[i]);
	}
}

/**************************************************************************************************
 *				Add Float Image
 **************************************************************************************************/
void AddFloatImage(float *img1, float *img2, int ncols, int nrows, float *img)
{
	int i;

	for(i = 0; i < ncols *nrows; i++)
	{
		img[i] = img1[i] + img2[i];
	}
}


/**************************************************************************************************
 *				Sub Float Image
 **************************************************************************************************/
void SubFloatImage(float *img1, float *img2, int ncols, int nrows, float *img)
{
	int i;

	for(i = 0; i < ncols *nrows; i++)
	{
		img[i] = img2[i] - img1[i];
	}
}

/**************************************************************************************************
 *				Add Average of Two Float Image
 **************************************************************************************************/
void AveFloatImage(float *img1, float *img2, int ncols, int nrows, float *img)
{
	int i;

	for(i = 0; i < ncols *nrows; i++)
	{
		img[i] = (img1[i] + img2[i])/2;
	}
}

/**************************************************************************************************
 *						Basic Functions
 **************************************************************************************************/
int EnforceRange(int x, int MaxValue)
{
	return (MIN(MAX(x, 0), MaxValue - 1));
}

/**************************************************************************************************
 *		Write the Magnitude of flow
 **************************************************************************************************/
void WriteMag(float *u, float *v, int ncols, int nrows, float *flow)
{
	int i, j, index;
	float tempu, tempv;
	double tempflow;

	for(i = 0; i < nrows; i++)
	{
		for(j = 0; j < ncols; j++)
		{
			index = i * ncols + j;
			tempu = u[index] ;
			tempv = v[index];
			tempflow = tempu*tempu + tempv*tempv;
			flow[index] = (float)(sqrt(tempflow));
		}
	}
}



/**************************************************************************************************
 *		Save the magnitude as pgm format
 **************************************************************************************************/
void WriteMagFile(char *fname, int ncols, int nrows, float *u, float*v)
{
	float *flow;
	flow = CreateFloatImage(ncols, nrows);
	WriteMag(u, v, ncols, nrows, flow);
	WriteFloatImageToBin(flow, ncols, nrows, fname);
	FreeFloatImage(flow);
	printf("Write .pgm format Success!\n");
}

/**************************************************************************************************
 *	Save Flow(u,v) as .flo format
 **************************************************************************************************/
void WriteFlo(FILE *fp, int ncols, int nrows, float *flow)
{
	/*Write .flo header*/
	rewind(fp);
	fprintf(fp, "PIEH");
	fwrite(&ncols, sizeof(int), 1, fp);
	fwrite(&nrows, sizeof(int), 1, fp);

	/*Write Flow Data*/
	fwrite(flow, 2 * ncols * nrows * sizeof(float), 1, fp);
	//fprintf(fp,"%f%f", u[index], v[index]);
}


/**************************************************************************************************
 *	Convert Flow u and v as a (u,v) .flow
 **************************************************************************************************/
void ConvertFlow(float *flow, int ncols, int nrows, float *u, float *v)
{
	int i, j;
	int offset = 0;
	int index;

	float *ptrflow = flow;
	float tempu, tempv;
	for(i = 0; i < nrows; i++)
	{
		for(j = 0; j < ncols; j++)
		{
			index = i*ncols+j;

			tempu = u[index];
			tempv = v[index];

			ptrflow[offset] = tempu;
			offset++;
			ptrflow[offset] = tempv;
			offset++;
		}
	}
}

void WriteFloFile(char *fname, int ncols, int nrows, float *u, float *v)
{
	float *flow;
	FILE  *fp;
	if((fp = fopen(fname, "wb")) == NULL)
	{
		printf("Can not allocate memory for %s!\n", fname);
	}

	flow = CreateFloatImage(2 * ncols, nrows);
	ConvertFlow(flow, ncols, nrows, u, v);
	WriteFlo(fp, ncols, nrows, flow);
	printf("Write .flo format Success!\n");
	FreeFloatImage(flow);
}





